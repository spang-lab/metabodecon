---
title: "Get Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", eval = FALSE)
```

This article illustrates how to use 'metabodecon' for deconvoluting and aligning one-dimensional NMR spectra, focusing on the preinstalled [sim](https://spang-lab.github.io/metabodecon/articles/Datasets.html#sim) dataset. The 'sim' dataset includes 16 simulated spectra, each with 1309 data points ranging from 3.6 to 3.4 ppm.  These simulations closely mimic the resolution and signal strength of real NMR experiments on blood plasma from 16 individuals. For more information on the _sim_ and _blood_ datasets, refer to the [Datasets](https://spang-lab.github.io/metabodecon/articles/Datasets.html) article.

# Deconvolute spectra

The function for deconvoluting 1D NMR spectra is `generate_lorentz_curves()`, which can be used as follows:

```{r}
sim_dir <- metabodecon::metabodecon_file("bruker/sim")
deconvs <- metabodecon::generate_lorentz_curves(
    data_path = sim_dir,  # path to the directory containing the spectra
    sfr = c(3.42, 3.58),  # borders of the signal free region (SFR) in ppm
    wshw = 0,             # half width of the water signal (WS) in ppm
    smopts = c(1, 5), # smooth by applying 1 time a moving average of size 5
    delta = 2   # filter peaks with scores smaller than `mu + sd * delta`,
                # where `mu` and `sd` are the mean and standard deviation of
                # peak-scores in the signal free region
)
```

After calling `generate_lorentz_curves()`, the function will request interactive user input, such as:

- Use same parameters for all spectra?
- Number of spectrum for adjusting parameters?
- Signal free region correctly selected?
- Water artefact fully inside red vertical lines?

For homogeneous datasets, e.g. human blood plasma measured in the same lab with the same acquisition and processing parameters, applying uniform parameters is usually fine. However, for heterogeneous datasets it's advisable to tailor parameters for each measurement type. The latter two prompts help verify the accuracy of the selected signal-free region (`sfr`) and water signal half width (`wshw`) [^wshw]. Adjustments can be made if the selections are inaccurate.

When using the function in scripts, where interactive user input is not desired, you can disable the interactive prompts by setting parameter `ask` to `FALSE`. In this case, the provided parameters will be used for the deconvolution of all spectra automatically. [^askFALSE]

[^wshw] Since the used dataset was simulated based on actual measurement in the range 3.6 to 3.4 ppm, it doesn't contain a water signal. Therefore, the water signal half width was set to zero.
[^askFALSE]: In this case it may be useful to set `ask = TRUE` for the first run to determine the optimal parameters interactively and then set `ask = FALSE` for subsequent runs.

# Visualize deconvoluted spectra

TODO

# Align deconvoluted spectra

The general workflow for aligning a set of deconvoluted spectra is as follows:

1. Look up global maximum and minimum ppm values over all spectra
2. Generate a matrix of features based on the spectrum data
3. Align the spectra using the 'speaq' package
4. Combine signals of peaks which are spread over adjacent columns

The following code snippets show, how the above steps can be implemented using the 'metabodecon' package:

## 1. Look up spectrum range

&#9888; Attention: below code snippet requires object `deconvs`, generated in section [Deconvolute spectra](#deconvolute-spectra). If you haven't run the code snippet from this section yet, please do so before continuing.

```{r}
ppm_range <- get_ppm_range(spectrum_data = deconvs)
ppm_range
```


## 2. Generate feature matrix

```{r}
feat <- gen_feat_mat(
  data_path = data_path,
  ppm_range = ppm_range,
  si_size_real_spectrum = 131072,
  scale_factor_x = 1000
)
head(feat)
```

In the above code snippet:

- Parameter `si_size_real_spectrum` of `gen_feat_mat()` gives the number of datapoints in each spectrum. [^si]
- Parameter `scale_factor_x` of `gen_feat_mat()` gives the scaling factor that was used during the deconvolution to prevent rounding errors.

[^si]: The name `si` is derived from the Bruker parameter "#SI" which gives the number of datapoints in the spectrum.

## 3. Align spectra

```{r}
after_speaq_mat <- speaq_align(feat = feat, maxShift = 50)
head(after_speaq_mat)
```

Parameter `maxShift` of `speaq_align()` gives the maximum number of points along the x axis a value can be moved by the 'speaq' package. A value of 50 may be used as start value for plasma spectra. However, depending on your spectra and the used digital resolution this value may be be adapted.

## 4. Combine peaks

```{r}
aligned_res <- combine_peaks(
  shifted_mat = after_speaq_mat,
  range = 5, # Number of adjacent columns to be used for improving alignment
  lower_bound = 1 # Number of columns that need to be skipped
  spectrum_data = spectrum_data,
  data_path = data_path
)
str(aligned_res, 1)
head(aligned_res$long)
head(aligned_res$short)
```

The final result of the alignment `aligned_res` is a list containing two matrices:

- `long`: the aligned matrix of signal intensities. Each row corresponds to a spectrum and each column to a chemical shift.
- `short`: same as `long`, but all columns containing only zeros have been removed.

Furthermore, results are written into two .csv files in your `data_path` directory "aligned_res_short.csv" and "aligned_res_long.csv".
