---
title: "Get Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
.sourceCode.txt {
  background-color: #f1f3f5;
}
figure {
  border: 1px solid #dee2e6;
  border-radius: .375rem;
  padding: 0;
  background-color: #f1f3f5;
}
figcaption {
  text-align: center;
  font-style: italic;
  border-top: 1px solid #dee2e6;
  padding: 0.75rem;
  background-color: #ffffff;
}
</style>

This article shows how Metabodecon can be used for deconvoluting and aligning one-dimensional NMR spectra using the pre-installed [Sim](https://spang-lab.github.io/metabodecon/articles/Datasets.html#sim) dataset as an example. The Sim dataset includes 16 simulated spectra, each with 1309 data points ranging from 3.6 to 3.4 ppm. These simulations closely mimic the resolution and signal strength of real NMR experiments on blood plasma from 16 individuals. For more information on the Sim and Blood datasets, refer to the [Datasets](https://spang-lab.github.io/metabodecon/articles/Datasets.html) article.

# Deconvolute spectra

The function for deconvoluting one-dimensional NMR spectra is `generate_lorentz_curves()`, which you can use as follows:

```R
sim_dir <- metabodecon::metabodecon_file("bruker/sim")
deconvs <- metabodecon::generate_lorentz_curves(
    data_path = sim_dir, # Path to directory containing spectra
    sfr = c(3.42, 3.58), # Borders of signal free region (SFR) in ppm
    wshw = 0,            # Half width of water signal (WS) in ppm
    smopts = c(1, 5),    # Smooth by applying 1 time a moving average of size 5
    delta = 0.1          # Configure threshold for peak filtering
)
```

```R
urine_dir <- metabodecon_file("bruker/urine")
urine_01_dir <- file.path(urine_dir, "urine_1")
urine_01_deconv <- generate_lorentz_curves(
    urine_01_dir, ask = FALSE
)
plot_spectrum(urine_01_deconv, foc_rgn = c(-1.9, -1.8), foc_unit = "ppm", trp_pch = c(17, 4, 4, 124))
plot_spectrum(urine_01_deconv, foc_rgn = c(0.25, 0.50))

sim_01_dir <- file.path(sim_dir, "sim_01")
sim_01_deconv <- metabodecon::generate_lorentz_curves(
    sim_01_dir, sfr = c(3.42, 3.58), wshw = 0, smopts = c(1, 1), delta = -5, ask = FALSE
)
metabodecon::plot_spectrum(sim_01_deconv, foc_rgn = c(0.25, 0.50))
metabodecon::plot_spectrum(sim_01_deconv, foc_rgn = c(0.00, 0.25))
```

After calling `generate_lorentz_curves()`, the function will prompt you with the following questions to determine the optimal deconvolution parameters:

1. Use same parameters for all spectra? (y/n)
2. Number of spectrum for adjusting parameters? (1: sim_01, 2: sim_02, ...)
3. Signal free region correctly selected? (y/n)
4. Water artefact fully inside red vertical lines? (y/n)

You can answer questions one and two with `y` and `1`, as the dataset is homogeneous, i.e., all spectra were measured in the same lab with the same acquisition and processing parameters. However, for heterogeneous datasets, it's advisable to optimize parameters for each batch of spectra individually.

Questions three and four are accompanied by the plots from [Figure 1](#fig-sim01-sfr-and-wsr), which help you verify the accuracy of the selected signal-free region (SFR) and water signal half-width (WSHW) [^wshw]. In this case, the provided parameters are already fine, so you can answer both questions with `y`. If adjustments are needed, you can respond with `n` and input the correct values.

<figure id="fig-sim01-sfr-and-wsr">
<img src="Get_Started\sim_01_param_checking.svg" alt="sim_01_param_checking.svg">
<figcaption>
<strong>Figure 1.</strong>
The sim_01 spectrum.
The x-Axis gives the chemical shift of each datapoint in parts per million (ppm).
The y-Axis gives the signal intensity of each datapoint in arbitrary units (au).
The borders of the signal free region are shown as green vertical lines in the left plot.
The center of the water signal is shown as a red vertical line in the right plot.
Because the water signal half width is set to zero, the borders of the water signal region equal its center.
</figcaption>
</figure>

When using the function in scripts, where interactive user input is not desired, you can disable the interactive prompts by setting parameter `ask` to `FALSE`. In this case, the provided parameters will be used for the deconvolution of all spectra automatically. [^askFALSE]

# Visualize deconvoluted spectra

After completing the deconvolution, it is advisable to visualize the extracted signals using `plot_spectrum()` to assess the quality of the deconvolution:

```R
# Visualize the first spectrum only
metabodecon::plot_spectrum(deconvs[[1]], foc_rgn = c(0.25, 0.50))
metabodecon::plot_spectrum(deconvs[[1]], foc_rgn = c(0.00, 0.25))

# Visualize all spectra and save them to a pdf file
pdfpath <- tempfile(fileext = ".pdf")
pdf(pdfpath)
for (i in seq_along(deconvs)) {
    metabodecon::plot_spectrum(
        decon   = deconvs[[i]],
        main    = deconvs[[i]]$filename,
        foc_rgn = c(0.4, 0.6)
    )
}
dev.off()
```

Out of the 16 generated plots, the first two are shown as examples in [Figure 2](#fig-sim1-plots).

<figure id="fig-sim1-plots">
<img src="Get_Started\sim_01_spectrum.svg" alt="sim_01_spectrum.svg" width = 49%>
<figcaption>
<strong>Figure 2.</strong>
TODO
</figcaption>
</figure>

# Align deconvoluted spectra

The general workflow for aligning a set of deconvoluted spectra is as follows:

1. Look up global maximum and minimum ppm values over all spectra
2. Generate a matrix of features based on the spectrum data
3. Align the spectra using the 'speaq' package
4. Combine signals of peaks which are spread over adjacent columns

The following code snippet shows, how the above steps can be done using the 'metabodecon' package:

## 1. Look up spectrum range

&#9888; Attention: below code snippet requires object `deconvs`, generated in section [Deconvolute spectra](#deconvolute-spectra). If you haven't run the code snippet from this section yet, please do so before continuing.

```{r}
ppm_range <- get_ppm_range(spectrum_data = deconvs)
ppm_range
```


## 2. Generate feature matrix

```{r}
feat <- gen_feat_mat(
  data_path = data_path,
  ppm_range = ppm_range,
  si_size_real_spectrum = 131072,
  scale_factor_x = 1000
)
head(feat)
```

In the above code snippet:

- Parameter `si_size_real_spectrum` of `gen_feat_mat()` gives the number of datapoints in each spectrum. [^si]
- Parameter `scale_factor_x` of `gen_feat_mat()` gives the scaling factor that was used during the deconvolution to prevent rounding errors.

[^si]: The name `si` is derived from the Bruker parameter "#SI" which gives the number of datapoints in the spectrum.

## 3. Align spectra

```{r}
after_speaq_mat <- speaq_align(feat = feat, maxShift = 50)
head(after_speaq_mat)
```

Parameter `maxShift` of `speaq_align()` gives the maximum number of points along the x axis a value can be moved by the 'speaq' package. A value of 50 may be used as start value for plasma spectra. However, depending on your spectra and the used digital resolution this value may be be adapted.

## 4. Combine peaks

```{r}
aligned_res <- combine_peaks(
  shifted_mat = after_speaq_mat,
  range = 5, # Number of adjacent columns to be used for improving alignment
  lower_bound = 1 # Number of columns that need to be skipped
  spectrum_data = spectrum_data,
  data_path = data_path
)
str(aligned_res, 1)
head(aligned_res$long)
head(aligned_res$short)
```

The final result of the alignment `aligned_res` is a list containing two matrices:

- `long`: the aligned matrix of signal intensities. Each row corresponds to a spectrum and each column to a chemical shift.
- `short`: same as `long`, but all columns containing only zeros have been removed.

Furthermore, results are written into two .csv files in your `data_path` directory "aligned_res_short.csv" and "aligned_res_long.csv".

<!-- Footnotes -->

[^wshw]: Since the used dataset was simulated based on actual measurement in the range 3.6 to 3.4 ppm, it doesn't contain a water signal. Therefore, the water signal half width was set to zero.
[^askFALSE]: In this case it may be useful to set `ask = TRUE` for the first run to determine the optimal parameters interactively and then set `ask = FALSE` for subsequent runs.