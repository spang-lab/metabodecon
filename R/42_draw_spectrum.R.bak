# Helpers #####

#' @noRd
#' @return Returns a list with the following elements:
#' - `cs`: Chemical Shifts
#' - `si`: Raw Signal Intensities
#' - `sm`: Smoothed Signal Intensities
#' - `ipc`: Peak Indices Center
#' - `ipl`: Peak Indices Left
#' - `ipr`: Peak Indices Right
#' - `idp`: Indices of Data Points
#' - `ipp`: Indices of Peak Points
#' - `inp`: Indices of Non-Peak Points
#' - `foc_lim`: Limits of Focus Region
#' - `ifr`: Indices of Focus Region
#' - `x_0`: Lorentzian Center
#' - `A`: Lorentzian Amplitude
#' - `lambda`: Lorentzian Width
#' - `x`: X-axis values
#' - `y`: Y-axis values
#' - `xlim`: X-axis limits
#' - `ylim`: Y-axis limits
ds_get_dat <- function(args) {
    obj <- args$obj
    foc_rgn <- args$foc_rgn
    foc_unit <- args$foc_unit
    foc_only <- args$foc_only
    sf_y_raw <- args$sf_y_raw
    ysquash <- args$ysquash

    # Chemical Shift & Signal Intensity
    cs <- obj[["cs"]] %||% obj[["ppm"]] %||% obj[["x_values_ppm"]]
    si <- obj[["si"]] %||% obj[["y_raw"]] %||% obj[["y_values_raw"]]
    sm <- obj[["sit"]][["sm"]] %||% obj[["y_smooth"]] %||% obj[["y_values"]]
    si <- si / sf_y_raw
    if (is.null(cs)) stop("Chemical shifts missing")

    # Peak Indices
    ipc <- obj$index_peak_triplets_middle # Peak centers
    ipl <- obj$index_peak_triplets_left # Peak borders left
    ipr <- obj$index_peak_triplets_right # Peak borders right
    idp <- rev(seq_along(cs)) # Data points
    ipp <- c(ipc, ipl, ipr) # Peak points
    inp <- setdiff(idp, ipp) # Non-peak points

    # Focus Region Limits
    foc_lim <- if (is.null(foc_rgn)) NULL
        else if (foc_unit == "fraction") quantile(cs, foc_rgn)
        else if (foc_unit == "ppm") foc_rgn
        else stop("foc_unit must be 'fraction' or 'ppm'")

    # Indices of Focus Region
    ifr <- if (is.null(foc_rgn)) integer()
        else which(cs > min(foc_lim) & cs < max(foc_lim))

    # Lorentzian Parameters
    x_0 <- obj$x_0_ppm
    A <- obj$A_ppm
    lambda <- obj$lambda_ppm

    # Plot region
    x <- if (foc_only) cs[ifr] else cs
    y <- if (foc_only) si[ifr] else si
    xlim <- c(max(x), min(x))
    ylim <- c(0, max(y) / ysquash)

    named(cs, si, sm, ipc, ipl, ipr, idp, ipp, inp, foc_lim, ifr, x_0, A, lambda, x, y, xlim, ylim)
}

ds_init_plot_region <- function(dat = ds_get_dat(),
                                verbose = FALSE) {
    if (verbose) logf("Initializing plot region")
    usr <- list(
        x    = dat$x,
        y    = dat$y,
        xlim = dat$xlim,
        ylim = dat$ylim,
        xaxs = "i",
        yaxs = "i",
        xlab = "",
        ylab = "",
        type = "n",
        axes = FALSE
    )
    do.call(plot, usr)
    ndc <- list(
        # Must be done AFTER plotting, or wrong user coords will be used
        xlim = grconvertX(usr$xlim, from = "user", to = "ndc"),
        ylim = grconvertY(usr$ylim, from = "user", to = "ndc")
    )
    named(usr, ndc)
}

ds_draw_bg <- function(dat = ds_get_dat(),
                        fill_col = NULL,
                        verbose = FALSE) {
    if (verbose) logf("Drawing background")
    bgr <- within(list(), {
        xleft <- dat$xlim[1]
        xright <- dat$xlim[2]
        ybottom <- dat$ylim[1]
        ytop <- dat$ylim[2]
        col <- fill_col
        border <- NA
    })
    if (!is.null(fill_col)) do.call(rect, bgr)
    return(bgr)
}

ds_draw_axis <- function(dat,
                          main = "",
                          xlab = "Chemical Shift [ppm]",
                          ylab = "Signal Intensity [au]",
                          axis_col = "black",
                          box_col = "black",
                          verbose = FALSE) {
    if (verbose) logf("Drawing axis")
    xtks <- seq(dat$xlim[1], dat$xlim[2], length.out = 5)
    ytks <- seq(dat$ylim[1], max(dat$y), length.out = 5)
    for (i in 2:12) if (length(unique(xtklabs <- round(xtks, i))) >= 5) break
    for (i in 2:12) if (length(unique(ytklabs <- round(ytks, i))) >= 5) break
    axis(
        side = 1, at = xtks, labels = xtklabs,
        col = NA, col.ticks = axis_col, col.axis = axis_col
    )
    axis(
        side = 2, at = ytks, labels = ytklabs,
        col = NA, col.ticks = axis_col, col.axis = axis_col, las = 1
    )
    title(main = main, xlab = xlab, ylab = ylab)
    box(col = box_col)
    named(xtks, ytks, xlab, ylab)
}

ds_draw_lines <- function(dat,
                          line_col = "black",
                          foc_only = FALSE,
                          sm_show = TRUE,
                          sm_col = "blue",
                          verbose = FALSE) {
    x <- if (foc_only) dat$cs[dat$ifr] else dat$cs
    y <- if (foc_only) dat$si[dat$ifr] else dat$si
    ys <- if (foc_only) dat$sm[dat$ifr] else dat$sm
    if (verbose) logf("Drawing raw signal")
    lines(x, y, type = "l", col = line_col, lty = 1)
    if (sm_show && !is.null(ys)) {
        if (verbose) logf("Drawing smoothed signal")
        lines(x, ys, type = "l", col = sm_col, lty = 1)
    }
}

ds_draw_triplets <- function(dat,
                              show = TRUE,
                              pch = c(17, 4, 4, NA),
                              col = c("red", "blue", "blue", "black"),
                              verbose = FALSE) {
    if (isFALSE(show)) return(NULL) # styler: off
    if (verbose) logf("Drawing peak triplets")
    x <- dat$cs
    y <- dat$sm %||% dat$si
    p <- dat$ipc
    l <- dat$ipl
    r <- dat$ipr
    q <- dat$inp
    points(x[p], y[p], col = col[1], pch = pch[1]) # 017 = triangle
    points(x[l], y[l], col = col[2], pch = pch[2]) # 000 = open square
    points(x[r], y[r], col = col[3], pch = pch[3]) # 004 = x character
    points(x[q], y[q], col = col[4], pch = pch[4]) # 124 = vertical dash
}

ds_draw_focus_rectangle <- function(dat,
                                    show = TRUE,
                                    fill = rgb(0, 0, 1, alpha = 0.1),
                                    col = "blue",
                                    verbose = FALSE) {
    if (is.null(dat$foc_lim) || !show) return(NULL) # styler: off
    usr <- list(
        xleft = max(dat$foc_lim),
        xright = min(dat$foc_lim),
        ybottom = 0,
        ytop = max(dat$si[dat$ifr]) / 0.96,
        col = fill,
        border = col
    )
    ndc <- list(
        xleft = grconvertX(usr$xleft, to = "ndc"),
        xright = grconvertX(usr$xright, to = "ndc"),
        ybottom = grconvertY(usr$ybottom, to = "ndc"),
        ytop = grconvertY(usr$ytop, to = "ndc")
    )
    if (verbose) logf("Drawing focus rectangle")
    do.call(rect, usr)
    named(usr, ndc)
}

ds_draw_lorentz_curves <- function(dat, args = NULL, verbose = FALSE) {
    lc_show <- args$lc_show %||% TRUE
    lc_col <- args$lc_col %||% "black"
    lc_lty <- args$lc_lty %||% 1
    lc_fill <- args$lc_fill %||% transp(lc_col)
    sup_show <- args$sup_show %||% TRUE
    sup_col <- args$sup_col %||% "red"
    sup_lty <- args$sup_lty %||% 1
    foc_only <- args$foc_only %||% FALSE
    x <- if (foc_only) dat$cs[dat$ifr] else dat$cs
    if (verbose) logf("Drawing individual Lorentzian Curves")
    Y <- matrix(nrow = length(x), ncol = length(dat$A))
    for (i in seq_along(dat$A)) {
        Y[, i] <- ds_draw_lorentz_curve(
            x       = x,
            x_0     = dat$x_0[i],
            A       = dat$A[i],
            lambda  = dat$lambda[i],
            lc_show = lc_show,
            lc_col  = lc_col,
            lc_lty  = lc_lty,
            lc_fill = lc_fill,
            ylim    = dat$ylim
        )
    }
    if (sup_show) {
        if (verbose) logf("Drawing superposition of Lorentzian Curves")
        lines(x = x, y = rowSums(Y), col = sup_col, lty = sup_lty, type = "l")
    }
    invisible(NULL)
}

ds_draw_lorentz_curve <- function(x,
                                  x_0,
                                  A,
                                  lambda,
                                  lc_show = TRUE,
                                  lc_col = "black",
                                  lc_lty = 1,
                                  lc_fill = NULL,
                                  ylim) {
    y <- lorentz(x, x_0, A, lambda)
    if (lc_show) {
        near_zero <- abs(y) < min(ylim) + 0.001 * diff(ylim)
        y_big <- y[!near_zero]
        x_big <- x[!near_zero]
        lines(
            x = x_big,
            y = y_big,
            col = lc_col,
            lty = lc_lty,
            type = "l"
        )
    }
    if (!is.null(lc_fill)) {
        rect(
            xleft = x_0 + lambda,
            xright = x_0 - lambda,
            ybottom = par("usr")[3],
            ytop = lorentz(x_0, x_0, A, lambda),
            col = lc_fill,
            border = NA
        )
    }
    return(y)
}

ds_draw_legend <- function(dat, args, verbose = FALSE) {
    if (isFALSE(args$lgd)) return(invisible(NULL))
    if (verbose) logf("Drawing legend")
    dsc <- c("Raw Signal", "Smoothed Signal", "Single Lorentzian", "Sum of Lorentzians", "Peak Triplets")
    col <- c(args$line_col, args$sm_col, args$lc_col, args$sup_col, args$dp_col[1])
    lty <- c(1, 1, 1, 1, NA)
    pch <- c(NA, NA, NA, NA, args$dp_pch[1])
    keep <- c(
        !is.null(dat$si),
        args$sm_show && !is.null(dat$sm),
        args$lc_show && !is.null(dat$A),
        args$sup_show && !is.null(dat$A),
        args$dp_show && !is.null(dat$ipc)
    )
    df <- data.frame(dsc, col, lty, pch)[keep,]
    legend(x = "topright", legend = df$dsc, col = df$col, lty = df$lty, pch = df$pch)
}
