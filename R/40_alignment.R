# Exported Main #####

#' @export
#' @title Align Signals using speaq
#' @description Performs signal alignment across the individual spectra using the speaq package (Beirnaert C, Meysman P, Vu TN, Hermans N, Apers S, Pieters L, et al. (2018) speaq 2.0: A complete workflow for high-throughput 1D NMRspectra processing and quantification. PLoS Comput Biol 14(3): e1006018. https://www.doi.org/10.1371/journal.pcbi.1006018). The spectra deconvolution process yields the signals of all spectra. Due to slight changes in measurement conditions, e.g. pH variations, signal positions may vary slightly across spectra. As a consequence, prior to further analysis signals belonging to the same compound have to be aligned across spectra. This is the purpose of the speaq package.
#' @param feat (data frame) Contains data of the deconvoluted signals of all analyzed spectra before alignment.
#' @param maxShift (positive integer) maximum number of points along the "ppm-axis" which a value can be moved by speaq package e.g. 50. 50 is a suitable starting value for plasma spectra with a digital resolution of 128K. Note that this parameter has to be individually optimized depending on the type of analyzed spectra and the digital resolution. For urine which is more prone to chemical shift variations this value most probably has to be increased.
#' @param spectrum_data (data frame) The output generated by the function generate_lorentz_curves.
#' @param size_real_spectrum (positive integer) number of real data points in your original spectra, e.g. 128k = 131072 data points
#' @details The output of speaq_align is a data matrix of aligned integral values. Each row contains the data of each spectrum and each column corresponds to one data point. Each entry corresponds to the integral of a deconvoluted signal with the signal center at this specific position after alignment by speaq.
#' @return A matrix containing the aligned integral values of all spectra.
#' @examples
#' \dontrun{
#' after_speaq_mat <- speaq_align(feat, maxShift)
#' }
speaq_align <- function(feat, maxShift, spectrum_data, size_real_spectrum) {
    # First identify reference spectrum
    resFindRef <- speaq::findRef(feat$peakList)
    # Save index of reference spectrum i.e the spectrum which all others will be aligned to
    refInd <- resFindRef$refInd
    # Use overwritten CluPA function for multiple spectra
    data_result_aligned <- dohCluster(feat$data_matrix, peakList = feat$peakList, refInd = refInd, maxShift = maxShift, acceptLostPeak = FALSE, verbose = TRUE)
    # data_result_aligned$Y contains matrix of aligned spectra each row corresponds to one spectrum
    # data_result_aligned$new_peakList contains the aligned signals of each spectrum

    # Aligned spectra values
    data_matrix_aligned <- data_result_aligned$Y
    # new peak list values
    new_peakList <- data_result_aligned$new_peakList
    # Recalculate peakList for the original format
    num_spectra <- dim(data_matrix_aligned)[1]
    peakList_result <- vector(mode = "list", length = num_spectra)
    for (i in 1:length(new_peakList)) {
        peakList_result[[i]] <- (dim(feat$data_matrix)[2]) - new_peakList[[i]]
    }

    # Generate feature matrix and integral matrix by using distance matrix
    # message("Warning: Generation of feature matrix and integral matrix have a high time duration (about 4h!)")
    # Calculate integral results for each positions
    integral_results <- vector(mode = "list", length = num_spectra)
    # Calculate integral_results
    for (spec in 1:length(peakList_result)) {
        for (ent in 1:length(peakList_result[[spec]])) {
            # Calculate integral value for each entry which is unequal 0
            if (peakList_result[[spec]][ent] != 0) {
                integral_results[[spec]][ent] <- feat$A[[spec]][ent] * (atan((-peakList_result[[spec]][ent] + 131072) / feat$lambda[[spec]][ent]) - atan((-peakList_result[[spec]][ent]) / feat$lambda[[spec]][ent]))
            }
        }
    }

    # Generate a matrix containing the integrals of all spectra at their positions after alignment by speaq
    after_speaq_mat <- matrix(nrow = num_spectra, ncol = size_real_spectrum)
    # set ppm values for data points of matrix based on original data
    # Note signals will be shifted across data points, data points itself will keep their positions.
    colnames(after_speaq_mat) <- spectrum_data[[1]]$x_values_ppm
    mid_spec <- round(size_real_spectrum / 2)
    for (i in 1:num_spectra)
    {
        for (j in 1:length(peakList_result[[i]]))
        {
            k <- round(peakList_result[[i]][j])
            k1 <- mid_spec - (k - mid_spec) # mirror imaging of data at mid data point
            after_speaq_mat[i, k1] <- integral_results[[i]][j]
        }
    }
    return(after_speaq_mat)
}

#' @export
#' @title Generate Feature Matrix.
#' @description Generate a feature matrix.
#' @param data_path Path to the parent folder of where the original spectra are stored. After deconvolution this folder also contains for each spectrum two .txt files which contain for each spectrum the spectrum approximated from all deconvoluted signals and a parameter file that contains all numerical values of the deconvolution
#' @param ppm_range (numeric) this is the result from the function [get_ppm_range()] i.e the ppm range over which your signals are distributed.
#' @param size_real_spectrum (positive integer) number of real data points in your original spectra, e.g. 128k = 131072 data points
#' @param scale_factor_x  (positive integer): A factor which is used to avoid rounding errors e.g. 1000
#' @details The output of this function is a data frame containing a matrix of all integral values found in your spectra (data_matrix). Here, each row corresponds to one spectrum and each column to one data point of the spectra, for example 128k data points in each spectrum correspond to 128K columns in the data matrix. Furthermore, a list of all signals(peakList), and individual parameters of the signals are stored in the data structure.
#' @return A list containing the data matrix, the peakList, the w, A and lambda values.
#' @examples
#' \dontrun{
#' res <- gen_feat_mat(data_path, ppm_range, size_real_spectrum, scale_factor_x)
#' }
gen_feat_mat <- function(data_path,
                         ppm_range,
                         size_real_spectrum,
                         scale_factor_x) {
    # Set highest/lowest ppm value and range
    message("Loading ppm range")
    ppm_highest_value <- max(ppm_range)
    ppm_lowest_value <- min(ppm_range)
    ppm_range <- ppm_highest_value - ppm_lowest_value

    # Import data sets
    message("Importing data")
    your_path_spectra <- data_path
    # Be careful: `data_path` should only contain txt files of MetaboDecon1D
    files <- list.files(your_path_spectra, ".txt")
    num_spectra <- length(files) / 2

    # Import spectra datasets
    message("Importing spectra")
    data_spectrum <- vector(mode = "list", length = num_spectra)
    data_info <- vector(mode = "list", length = num_spectra)
    numerator_info <- 1
    numerator_spectrum <- 1
    for (i in 1:length(files)) {
        if (grepl(" parameters", files[i])) {
            data_info[[numerator_info]] <- as.matrix(data.table::fread(files[i], header = FALSE))
            numerator_info <- numerator_info + 1
        }

        if (grepl(" approximated_spectrum", files[i])) {
            data_spectrum[[numerator_spectrum]] <- as.vector(unlist(data.table::fread(files[i], header = FALSE)))[-1]
            numerator_spectrum <- numerator_spectrum + 1
        }
    }
    message("Converting parameters to list")

    # Save parameters in list
    w <- vector(mode = "list", length = num_spectra)
    lambda <- vector(mode = "list", length = num_spectra)
    A <- vector(mode = "list", length = num_spectra)
    noise_threshold <- vector(mode = "list", length = num_spectra)
    spectrum_approx <- vector(mode = "list", length = num_spectra)
    vec_num_Lorentz_curves <- numeric(num_spectra)

    for (i in 1:num_spectra) {
        w[[i]] <- as.numeric(data_info[[i]][1, ][-1])
        lambda[[i]] <- as.numeric(data_info[[i]][2, ][-1])
        A[[i]] <- as.numeric(data_info[[i]][3, ][-1])
        noise_threshold[[i]] <- as.numeric(data_info[[i]][4, ][2])
        spectrum_approx[[i]] <- data_spectrum[[i]]
        vec_num_Lorentz_curves[i] <- length(w[[i]])
    }

    message("Checking for irregular values")
    # Remove zeros
    for (i in 1:num_spectra) {
        w_values <- w[[i]]
        A_values <- A[[i]]
        lambda_values <- lambda[[i]]

        # Find position of 0's
        zero_positions <- which(w[[i]] == 0)

        # If zero_positions is filled
        if (length(zero_positions) > 0) {
            w[[i]] <- w_values[-zero_positions]
            A[[i]] <- A_values[-zero_positions]
            lambda[[i]] <- lambda_values[-zero_positions]
        } else {
            w[[i]] <- w_values
            A[[i]] <- A_values
            lambda[[i]] <- lambda_values
        }
    }

    # Generate data matrix
    data_matrix <- matrix(nrow = 0, ncol = length(data_spectrum[[1]]))
    for (i in 1:num_spectra) {
        data_matrix <- rbind(data_matrix, data_spectrum[[i]])
    }

    # Generate peakList
    # Here the peaks are substracted of real size of spectra to compensate
    # problems of shifting of speaq package. This is changed later again
    peakList <- vector(mode = "list", length = num_spectra)
    for (i in 1:num_spectra) {
        peakList[[i]] <- (dim(data_matrix)[2]) - (w[[i]] * scale_factor_x)
    }
    return_list <- list("data_matrix" = data_matrix, "peakList" = peakList, "w" = w, "A" = A, "lambda" = lambda)
    return(return_list)
}

#' @export
#' @title Combine Peaks
#' @description Even after alignment of spectra, alignment of individual signals is not always perfect, as a segment-wise alignment is performed i.e. groups of signals are aligned. For further improvements, partly filled neighboring columns are merged.
#' @param shifted_mat (matrix) the matrix obtained after alignment by speaq.
#' @param range (positive integer) amount of adjacent columns which are permitted to be used for improving the alignment e.g. 5.
#' @param lower_bound (positive integer) amount of columns that need to be skipped (f.e. because they contain rownames instead of values, only modify in case of errors) default=1.
#' @param spectrum_data (data frame) The output generated by the function generate_lorentz_curves
#' @param data_path (string) Path to the parent folder where the original spectra are stored. After deconvolution this folder also contains for each spectrum two .txt files which contain for each spectrum the spectrum approximated from all deconvoluted signals and a parameter file that contains all numerical values of the deconvolution
#' @return A list containing two data frames `long` and `short`. The first one contains one for one column for each data point in the original spectrum. The second one contains only columns where at least one entry is non-zero. The returned data.frames are additionally written to disk as .csv files `aligned_res_long.csv` and `aligned_res_short.csv`.
#' @examples
#' \dontrun{
#' aligned_res <- combine_peaks(after_speaq_mat, range, lower_bound, spectrum_data, data_path)
#' }
combine_peaks <- function(shifted_mat,
                          range,
                          lower_bound,
                          spectrum_data,
                          data_path) {
    shifted_mat_no_na <- replace(is.na(shifted_mat), 0)
    col_entries <- numeric(ncol(shifted_mat_no_na))
    for (i in 1:ncol(shifted_mat_no_na)) {
        col_entries[i] <- length(which(shifted_mat_no_na[, i] != 0))
    }
    bla <- shifted_mat_no_na != 0
    shifted_mat_no_na <- shifted_mat_no_na
    for (i in (nrow(shifted_mat_no_na) - 1):lower_bound) {
        print(i)
        indices <- which(col_entries == i)
        for (j in indices) {
            if (col_entries[j] != 0) {
                while (T) {
                    bli <- rep(0, 2 * range)
                    l <- 0
                    search_range <- c((j - range):(j - 1), (j + 1):(j + range))
                    for (k in search_range) {
                        l <- l + 1
                        if (all(which(bla[, k]) %in% which(!bla[, j]))) {
                            bli[l] <- col_entries[k]
                        }
                    }
                    if (all(bli == 0)) {
                        break
                    } else {
                        index_max <- search_range[which.max(bli)]

                        shifted_mat_no_na[, j] <- shifted_mat_no_na[, j] + shifted_mat_no_na[, index_max]
                        bla[, j] <- bla[, j] | bla[, index_max]
                        col_entries[j] <- col_entries[j] + col_entries[index_max]
                        shifted_mat_no_na[, index_max] <- 0
                        bla[, index_max] <- F
                        col_entries[index_max] <- 0
                    }
                }
            }
        }
    }
    colnames(shifted_mat_no_na) <- as.character(round(spectrum_data[[1]]$x_values_ppm, digits = 4))
    # removal of columns containing only zeros
    kick.out <- apply(shifted_mat_no_na, 2, function(z) {
        all(z == 0)
    })
    shifted_mat_no_na_s <- shifted_mat_no_na[, !kick.out]
    utils::write.csv2(shifted_mat_no_na, file = file.path(data_path, "aligned_res_long.csv"))
    utils::write.csv2(shifted_mat_no_na_s, file = file.path(data_path, "aligned_res_short.csv"))
    return_list <- list("short" = shifted_mat_no_na_s, "long" = shifted_mat_no_na)
    return(return_list)
}

#' @export
#' @title dohCluster
#' @description Helper of [speaq_align()].
#' @param X `data_matrix` as returned by [gen_feat_mat()]
#' @param peakList `peakList` as returned by function [gen_feat_mat()]
#' @param refInd Number of the reference spectrum i.e. the spectrum to which all signals will be aligned to.
#' @param maxShift Maximum number of points along the "ppm-axis" which a value can be moved (e.g. 50).
#' @param acceptLostPeak (logic) default is TRUE
#' @param verbose (logic) default is TRUE
#' @return A list containing two data frames `Y` and `new_peakList`. The first one contains the aligned spectra, the second one contains the aligned signals of each spectrum.
#' @details The function dohCluster of the speaq package has been rewritten to be compatible with the data generated by MetaboDecon1D and the function gen_feat_mat and to return a new peakList of aligned spectra. Overwrite original dohCluster function of speaq package. Function is able to return the new peakList of aligned spectra.
#' @examples
#' \dontrun{
#' res <- dohCluster(X, peakList, refInd = 0, maxShift = 100, acceptLostPeak = TRUE, verbose = TRUE)
#' }
dohCluster <- function(X, peakList, refInd = 0, maxShift = 100, acceptLostPeak = TRUE, verbose = TRUE) {
    if (is.null(maxShift)) {
        if (verbose) {
            cat("\n --------------------------------")
            cat("\n maxShift=NULL, thus dohCluster will automatically detect the optimal value of maxShift.")
            cat("\n --------------------------------\n")
        }
        res <- dohCluster_withoutMaxShift(X = X, peakList = peakList, refInd = refInd, acceptLostPeak = acceptLostPeak, verbose = verbose)
    } else {
        if (verbose) {
            cat("\n --------------------------------")
            cat("\n dohCluster will run with maxShift=", maxShift)
            cat("\n If you want dohCluster to detect the optimal maxShift automatically,")
            cat("\n use dohCluster(..., maxShift = NULL, ...)")
            cat("\n --------------------------------\n")
        }
        res <- dohCluster_withMaxShift(X = X, peakList = peakList, refInd = refInd, maxShift = maxShift, acceptLostPeak = acceptLostPeak, verbose = verbose)
    }
    return(res)
}

# Exported Helpers #####

#' @export
#' @title Get ppm range
#' @author Wolfram Gronwald, Tobias Schmidt
#' @description Returns the ppm range across all peaks of the provided deconvoluted spectra.
#' @param spectrum_data A list of deconvoluted spectra as returned by [generate_lorentz_curves()].
#' @param show Whether to plot the ppm range on the spectrum plot.
#' @return A vector containing the lowest and highest ppm value over all peaks of the provided deconvoluted spectra.
#' @examples
#' sim <- metabodecon_file("bruker/sim_subset")
#' decons <- generate_lorentz_curves(
#'      sim, sfr = c(3.58, 3.42), wshw = 0,
#'      ask = FALSE, verbose = FALSE
#' )
#' ppm_rng <- get_ppm_range(decons, show = TRUE)
#' print(ppm_rng)
get_ppm_range <- function(spectrum_data, show = FALSE) {
    ss <- spectrum_data
    ppm_min <- min(sapply(ss, function(s) min(s$peak_triplets_middle)))
    ppm_max <- max(sapply(ss, function(s) max(s$peak_triplets_middle)))
    ppm_rng <- c(ppm_min, ppm_max)
    if (show) {
        ymax <- max(sapply(ss, function(s) max(s$y_values)))
        xrng <- range(c(sapply(ss, function(s) s$x_values_ppm)))
        y0.8 <- ymax * 0.8
        a <- ppm_rng[1]
        b <- ppm_rng[2]
        cols <- rainbow(length(ss))
        alen <- (b - a) / 4
        lgdtxt <- paste("Spectrum", 1:length(ss))
        plot(NA, type = "n", xlim = xrng[2:1], ylim = c(0, ymax), ylab = "Signal Intensity [au]", xlab = "Chemical Shift [ppm]")
        abline(v = ppm_rng, lty = 2)
        for (i in 1:length(ss)) {
            lines(ss[[i]]$x_values_ppm, ss[[i]]$y_values, col = cols[i])
        }
        arrows(
            x0 = c(a + alen, b - alen), x1 = c(a, b),
            y0 = y0.8, y1 = y0.8,
            length = 0.1, lty = 2, col = "black"
        )
        text(mean(c(a, b)), y0.8, "ppm range")
        mtext(round(c(a, b), 4), side = 3, line = 0, at = c(a, b))
        legend("topright", legend = lgdtxt, col = cols, lty = 1)
    }
    ppm_rng
}

# Private Helpers #####

dohCluster_withoutMaxShift <- function(X,
                             peakList,
                             refInd = 0,
                             acceptLostPeak = TRUE,
                             verbose = TRUE) {
    if (verbose) {
        startTime <- proc.time()
    }
    maxShift_ladder <- 2^(c(1:trunc(log2(ncol(X) / 2))))
    bestCor <- -1
    corVec <- NULL
    bestY <- NULL
    bestMaxShift <- 0
    for (maxShift_val in maxShift_ladder) {
        if (verbose) {
            cat("\n maxShift=", maxShift_val)
        }
        Y <- X
        peakListNew <- peakList
        refSpec <- Y[refInd, ]
        for (tarInd in seq_len(nrow(X))) {
            if (tarInd != refInd) {
                targetSpec <- Y[tarInd, ]
                myPeakList <- c(peakList[[refInd]], peakList[[tarInd]])
                myPeakLabel <- c(
                    rep(1, length(peakList[[refInd]])),
                    rep(0, length(peakList[[tarInd]]))
                )
                startP <- 1
                endP <- length(targetSpec)
                res <- speaq::hClustAlign(
                    refSpec,
                    targetSpec,
                    myPeakList,
                    myPeakLabel,
                    startP,
                    endP,
                    maxShift = maxShift_val,
                    acceptLostPeak = acceptLostPeak
                )
                Y[tarInd, ] <- res$tarSpec
                if (length(myPeakList) > length(res$peakList)) {
                    peakListNew[[tarInd]] <- res$peakList[(length(peakList[[refInd]]) +
                        1):length(res$peakList)]
                } else {
                    peakListNew[[tarInd]] <- res$peakList[(length(peakList[[refInd]]) +
                        1):length(myPeakList)]
                }
            }
        }
        Z <- stats::cor(t(Y))
        newCor <- stats::median(Z[lower.tri(Z)])
        corVec <- c(corVec, newCor)
        if (verbose) {
            cat(
                "\n Median Pearson correlation coefficent:",
                newCor, ", the best result:", bestCor
            )
        }
        if (newCor > bestCor) {
            bestCor <- newCor
            bestY <- Y
            bestMaxShift <- maxShift_val
        }
    }
    if (verbose) {
        cat(
            "\nOptimal maxShift=", bestMaxShift, "with median Pearson correlation of aligned spectra=",
            bestCor
        )
        plot(log2(maxShift_ladder), corVec,
            type = "b",
            xlab = "log2(maxShift)", ylab = "Median Pearson correlation coefficent",
            main = paste("Optimal maxShift=", bestMaxShift,
                " (red star) \n with median Pearson correlation coefficent of ",
                round(bestCor, 6),
                sep = ""
            )
        )
        graphics::points(log2(bestMaxShift), bestCor, col = "red", pch = 8, cex = 2)
    }
    if (verbose) {
        endTime <- proc.time()
        cat(
            "\n Alignment time: ", (endTime[3] - startTime[3]) / 60,
            " minutes"
        )
    }
    # Added by me at 31.08.21
    return_list <- list("Y" = bestY, "new_peakList" = peakListNew)
    return(return_list)
}

dohCluster_withMaxShift <- function(X,
                          peakList,
                          refInd = 0,
                          maxShift = 100,
                          acceptLostPeak = TRUE,
                          verbose = TRUE) {
    Y <- X
    peakListNew <- peakList
    if (verbose) {
        startTime <- proc.time()
    }
    refSpec <- Y[refInd, ]
    for (tarInd in seq_len(nrow(X))) {
        if (tarInd != refInd) {
            if (verbose) {
                cat("\n aligning spectrum ", tarInd)
            }
            targetSpec <- Y[tarInd, ]
            myPeakList <- c(peakList[[refInd]], peakList[[tarInd]])
            myPeakLabel <- double(length(myPeakList))
            for (i in seq_along(peakList[[refInd]])) myPeakLabel[i] <- 1
            startP <- 1
            endP <- length(targetSpec)
            res <- speaq::hClustAlign(
                refSpec,
                targetSpec,
                myPeakList,
                myPeakLabel,
                startP,
                endP,
                maxShift = maxShift,
                acceptLostPeak = acceptLostPeak
            )
            Y[tarInd, ] <- res$tarSpec
            if (length(myPeakList) > length(res$peakList)) {
                peakListNew[[tarInd]] <- res$peakList[(length(peakList[[refInd]]) +
                    1):length(res$peakList)]
            } else {
                peakListNew[[tarInd]] <- res$peakList[(length(peakList[[refInd]]) +
                    1):length(myPeakList)]
            }
        }
    }
    if (verbose) {
        Z <- stats::cor(t(Y))
        newCor <- stats::median(Z[lower.tri(Z)])
        cat(
            "\n Median pearson correlation of aligned spectra:",
            newCor
        )
        endTime <- proc.time()
        cat(
            "\n Alignment time: ", (endTime[3] - startTime[3]) / 60,
            " minutes"
        )
    }

    # Added modifications:
    return_list <- list("Y" = Y, "new_peakList" = peakListNew)
    return(return_list)
}
